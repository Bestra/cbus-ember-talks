* Replacing full stack tests with ember tests
** Definitions
   - full-stack tests are tests that run both the client and the server and interface via the browser.
     My example application uses [[https:github.com/teamcapybara/capybara][Capybara]] but there are similar projects for most languages and frameworks
* Good things about full-stack tests
** Tests the whole system
** Promotes thinking about the system from the user's point of view
** Some server/client interactions need to be tested together (websockets, etc)
** Creating test data is easier
   We use the same FactoryGirl factories to make data for capybara tests.
** Fewer total tests
* Bad things about full-stack tests?
** Often exercizes too much of the system for a given case
   With a traditional server-rendered application there's almost a 1:1 ratio of user actions to controller actions.
   With a client application the user could perform many actions before ever doing something that hits a controller.
*** Testing client-side validations with Capybara (they never hit the server)
*** Things that should be unit-tested are instead implicitly exercised with acceptance tests
**** Combinatorial possibilities when going up the stack
** Slow
** Fragile (system works, tests fail)
** High setup per test
** Offer little testability signal besides data setup
*** Testability can be a useful signal
**** If the system is hard to test, improving testability will often improve the overall design
***** Capybara tests give little indication of the frontend's testability for design purposes
**** Leverage things like Services and Components
**** Link to component testing blog post
* Auditing your test suite
** Redundancy wrt API boundaries
   I'm going to make up a fake rolodex page to use an example for testing.
Here's an example of an acceptance test we would've written early on in our app's life.
Instead of writing actual test code, I'm going to write out sequence diagram.
** Draw some sequence diagrams
   #+begin_src uml
Title: User can persist a new entry with all fields filled out.
User->App: visit "/rolodex/" URL
User->App: click "+"
User->App: fill in first name with "Steve"
User->App: fill in last name with "Jones"
User->App: fill in phone number with "112-3456"
User->App: click "Save"
Note over User: expect to see "saved"
User->App: reload page
Note over User: expect to see "Steve Jones" with "112-3456"
   #+end_src
This test creates a new entry in the rolodex, fills it out, saves, and then reloads
to ensure that the new entry was properly persisted.  That's a lot of things for a single test!
In some ways this is a great *smoke test*.  It verifies that a big chunk of the system is working in a holistic fashion.

Now I'll add three other tests.  
   #+begin_src uml
Title: User can persist a new entry omitting first name
User->App: visit "/rolodex/" URL
User->App: click "+"
User->App: fill in last name with "Jones"
User->App: fill in phone number with "112-3456"
User->App: click "Save"
Note over User: expect to see "saved"
User->App: reload page
Note over User: expect to see "Jones" with "112-3456"
   #+end_src

   #+begin_src uml
Title: User can NOT persist a new entry omitting last name
User->App: visit "/rolodex/" URL
User->App: click "+"
User->App: fill in phone number with "112-3456"
User->App: click "Save"
Note over User: expect to see error message for last name
User->App: reload page
Note over User: expect to see empty list
   #+end_src

   #+begin_src uml
Title: Save button is disabled when phone number has letters
User->App: visit "/rolodex/" URL
User->App: click "+"
User->App: fill in phone number with "FOO"
Note over User: expect save to be disabled
   #+end_src

All four of the tests here will test different parts of the same page.  How can I make it easier to see which
tests might be redundant as full-stack tests?  I'm going to add the API Server as an actor to my first test sequence
to give some granularity as to what I'm actually testing.

#+begin_src uml
Title: User can persist a new entry with all fields filled out.
User->Client: visit "/rolodex/" URL
Client->API: GET api/entries
API->Client: 200 {entries: []}
User->Client: click "+"
User->Client: fill in first name with "Steve"
User->Client: fill in last name with "Jones"
User->Client: fill in phone number with "112-3456"
User->Client: click "Save"
Client->API: POST api/entries {firstName: "Steve", ...}
API->Client: 201 {id: 1, firstName: "Steve", ...}
Note over User: expect to see "saved"
User->Client: reload page
Client->API: GET api/entries
API->Client: 200 {entries: [{id: 1, firstName: "Steve", ...}]}
Note over User: expect to see "Steve Jones" with "112-3456"
#+end_src

This test makes 3 server requests
- GET api/entries :: loads the list of entries from the server. 
- POST api/entries :: creates a new entry
- GET api/entries :: loads the list of entries from the server again


Here's the other test that deals with persistence, broken up in the same fashion.
#+begin_src plantuml
Title: User can NOT persist a new entry omitting last name
User->Client: visit "/rolodex/" URL
Client->API: GET api/entries
API->Client: 200 {entries: []}
User->Client: click "+"
User->Client: fill in first name with "Steve"
User->Client: fill in phone number with "112-3456"
User->Client: click "Save"
Client->API: POST api/entries {firstName: "Steve", ...}
API->Client: 422 {errors:{...}}
Note over User: expect to see error message for last name
#+end_src

This test makes 2 server requests
- GET api/entries :: loads the list of entries from the server. 
- POST api/entries :: creates a new entry (with errors)

** How many tests hit the same endpoints with the same kinds of requests?
   Both of the tests I just broke apart are interacting solely with the 'entries' endpoint.  No matter what happens on the client -
   whether the form is totally filled out, empty, or something in between -
   the end result from the server's point of view is just another permutation of a POST request.
   
   Full-stack tests that consume the same API endpoints are prime candidates for splitting into client-side tests and server-side tests.
** Having some full-stack tests is still important!
* Planning to convert a test
** Think about what the boundaries for new test(s) should be
   - What unique aspect of your application are you trying to test?
   - Describe guidelines for test boundaries
     - API calls
     - DOM side effects
   As an example of the high level process I use, I'm going to go back to the first persistence test from above, 'A user can persist an entry with all fields filled out.', and
   try to add in all the implicit assertions - thing that have to happen over the course of the test.
#+begin_src uml
Title: User can persist a new entry with all fields filled out.
User->Client: visit "/rolodex/" URL
Client->API: GET api/entries
Note over Client: visiting 'rolodex' route fetches all entries from the API
API->Client: 200 {entries: []}
Note over API: entries endpoint returns an empty array when there are no entries
User->Client: click '+'
Note over Client: clicking '+' shows the form for a new entry
User->Client: fill in first name with "Steve"
User->Client: fill in last name with "Jones"
User->Client: fill in phone number with "112-3456"
User->Client: click "Save"
Client->API: POST api/entries {firstName: "Steve", ...}
Note over Client: clicking 'Save' will post the new entry to the API with the form's data
API->Client: 201 {id: 1, firstName: "Steve", ...}
Note over API: entry endpoint returns a 201 with the newly persisted entry on success
Note over Client: client shows a message when the promise for saving resolves successfully
User->Client: reload page
Client->API: GET api/entries
Note over Client: visiting 'rolodex' route fetches all entries
API->Client: 200 {entries: [{id: 1, firstName: "Steve", ...}]}
Note over API: entries endpoint returns existing entries in the proper format
Note over Client: client shows all entries returned from the server
#+end_src

In a perfect world, there'd only be one test for each of those assertions in the entire test suite. Testing the whole stack can be great
because it does just that - a single test makes sure a whole bunch of things are correctly working in concert. For my purposes, though, I'd like to only
test the whole stack when the situation calls for it.  That means creating more tests that are more narrowly focused on either the front end or the back end.

For the time being I'll break this test up into a few client tests and a few server tests.  For the server side I'm going to assume something like [[https://relishapp.com/rspec/rspec-rails/docs/request-specs/request-spec][Rspec request specs]]. For the client
side I'll assume I'm using an Ember [[https://guides.emberjs.com/v2.14.0/testing/acceptance/][acceptance tests]], replacing the real API with a mock.
#+begin_src uml
Title: Ember 1 - Saving a new rolodex entry posts all the form data to the server
User->Client: visit "/rolodex/" URL
Client->Mock: GET api/entries
Mock->Client: 200 {entries: []}
User->Client: click '+'
User->Client: fill in first name with "Steve"
User->Client: fill in last name with "Jones"
User->Client: fill in phone number with "112-3456"
User->Client: click "Save"
Client->Mock: POST api/entries {firstName: "Steve", ...}
Note over Mock: Assert that POST occured with form data
Note over Client: Assert that success message appears
#+end_src

I'll go over some further details for mocking later.  For an acceptance test like this the client will normally need to load some data from the API as well as send data back.

** Pick ember test types based on the boundaries and needs
   - Navigation/routing
   - Making appropriate API calls
   - Granularity of user interaction
   A single capybara test might actually turn into several different Ember tests (more on that)

** Don't lose test coverage
   You may need to add new request specs to take the place of the old capybara test, in addition to the 
   new ember tests
* The conversion
** Creating Test Data
*** The most difficult part of creating ember tests
*** Mirage or FactoryGuy
*** Don't use custom serializers as justification for redundant testing
    Test the serializers separately with unit tests!
*** Component tests make loading test data much simpler
**** Acceptance tests will test authorization and data loading for all route segments.
**** The critical part of the system that you're trying to test might not care about any of that.
** API boundaries
*** Use mirage or mockjax to assert when needed
* Notes
  - Make sure to add actual examples of the capybara spec we're talking about
  - Give a brief refresher about what the spec is doing (what's the difference between the request spec, the feature spec, etc)
